DATABASE HW2

Q1-> http://www.sqlfiddle.com/#!15/8d646

INSERT INTO HotelStays(roomNum, arrDate, depDate, guestName)
VALUES 
(123, to_date('20160202', 'YYYYMMDD'), to_date('20160206','YYYYMMDD'), 'A'),
(123, to_date('20160204', 'YYYYMMDD'), to_date('20160208','YYYYMMDD'), 'B');

INSERT INTO HotelStays(roomNum, arrDate, depDate, guestName)
VALUES 
(201, to_date('20160210', 'YYYYMMDD'), to_date('20160206','YYYYMMDD'), 'C');
———————————————————————————————————————————————————————————————————————————
Implementation in case the sqlfiddle link doesn’t open:

CREATE TABLE HotelStays
( 
 roomNum INTEGER NOT NULL,
arrDate DATE NOT NULL,
depDate DATE NOT NULL,
guestName CHAR(30) NOT NULL,
PRIMARY KEY (roomNum, arrDate),
CHECK (depDate>arrDate));


    
CREATE OR REPLACE FUNCTION HotelStays_function() RETURNS TRIGGER AS $HotelStays_trigger$
    BEGIN
        --
        --
        
        IF EXISTS(SELECT h.roomNum FROM HotelStays h where h.roomNum 
            = NEW.roomNum and NEW.arrDate < h.depDate)  THEN
                  RAISE EXCEPTION 'cannot allot room No %', NEW.roomNum;
        END IF;
        RETURN NEW ; -- result is ignored since this is an AFTER trigger
    END;
$HotelStays_trigger$ LANGUAGE plpgsql;
             
CREATE TRIGGER HotelStays_trigger BEFORE INSERT
    ON HotelStays FOR EACH ROW
    WHEN (true)
    EXECUTE PROCEDURE HotelStays_function();


INSERT INTO HotelStays(roomNum, arrDate, depDate, guestName)
VALUES 
(123, to_date('20160202', 'YYYYMMDD'), to_date('20160206','YYYYMMDD'), 'A'),
(123, to_date('20160204', 'YYYYMMDD'), to_date('20160208','YYYYMMDD'), 'B');

INSERT INTO HotelStays(roomNum, arrDate, depDate, guestName)
VALUES 
(201, to_date('20160210', 'YYYYMMDD'), to_date('20160206','YYYYMMDD'), 'C');

—————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

Q2-> http://www.sqlfiddle.com/#!9/dc8de/1
———————————————————————————————————————————————————————-
Implementation in case the sqlfiddle link doesn’t open:

CREATE TABLE ENROL
(SID INTEGER,  
 ClassName CHAR(30), 
 Grade CHAR(5));
 
 INSERT INTO ENROL(SID,  ClassName, Grade) VALUES
 (123  ,'ART123',    'A'),(
123  ,'BUS456',    'B'),(
666  ,'REL100',    'D'),(
666  ,'ECO966',    'A'),(
666  ,'BUS456',    'B'),(
345  ,'BUS456',    'A'),(
345  ,'ECO966',    'F');

 CREATE VIEW ENROL_view AS 
 select ClassName,COUNT(*) from  ENROL  GROUP BY ClassName
 ORDER BY COUNT(*);

—————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

Q3-> http://www.sqlfiddle.com/#!9/87c4df/1
———————————————————————————————————————————
Implementation in case the sqlfiddle link doesn’t open:

create table PROJECT(
ProjectID char(9),  Step integer,  Status char(9));

insert into PROJECT values
('P100',       0     ,'C'),
('P100',       1     ,'W'),
('P100',       2    ,'W'),
('P201',       0    ,'C'),
('P201',       1     ,'C'),
('P333' ,      0     ,'W'),
('P333' ,      1     ,'W'),
('P333',       2     ,'W'),
('P333',       3     ,'W');

select t3.projectid from
(select distinct projectid from PROJECT t1 where step <> 0 and status='W' 
and not exists
(select 1 from PROJECT t2 where step <> 0 and status='C'
and t1.projectid = t2.projectid)
) t3 inner join (
select distinct projectid from PROJECT where step = 0 and status='C') t4
on t3.projectid = t4.projectid;

——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
 
Q4-> http://www.sqlfiddle.com/#!9/84fc7/1
 ————————————————————————————————————————-
Implementation in case the sqlfiddle link doesn’t open:

create table SPAM(
Name char(20),     Address char(20),  ID integer, SameFam integer);

insert into SPAM values (
'Alice'   ,'A'    ,  10 , NULL),
('Bob'     ,'B'  ,    15 , NULL),
('Carmen'  ,'C'     , 22 , NULL),
('Diego'   ,'A'    ,  9  , 10),
('Ella'    ,'B'   ,   3  , 15),
('Farkhad' ,'D'  ,    11 , NULL);


delete from SPAM where id in (
select id from 
(select samefam from SPAM where samefam is not null) t1
join
(select * from SPAM where samefam is null) t2 on t1.samefam = t2.id);

——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

Q5->  I have given 4 implementations of this solution
 
 	1. http://www.sqlfiddle.com/#!9/7c3cb/1
	2. http://www.sqlfiddle.com/#!9/cdad2/2
	3. http://www.sqlfiddle.com/#!9/157f6e/7
	4. runs in w3schools portal but could not test in qlfiddle due to instability of the tool. Please check the implementation below.
	
———————————————————————————————————————————————————————
Implementation in case the sqlfiddle link doesn’t open:


create table chefs (
chef char(2),         dish char(50));

create table dishes (
dish char(50));

insert into dishes values(
  'Apple pie'),('Creme brulee'),('Upside down pineapple cake');

insert into chefs values (
'A',          'Mint chocolate brownie'),(
'B' ,         'Upside down pineapple cake'),(
'B'  ,        'Creme brulee'),(
'B'   ,       'Mint chocolate brownie'),(
'C'    ,      'Upside down pineapple cake'),(
'C'     ,     'Creme brulee'),(
'D'      ,    'Apple pie'),(
'D'       ,   'Upside down pineapple cake'),(
'D'        ,  'Creme brulee'),(
'E'         , 'Apple pie'),(
'E'   ,       'Upside down pineapple cake'),(
'E'    ,      'Creme brulee'),(
'E'     ,     'Bananas Foster');


1) http://www.sqlfiddle.com/#!9/7c3cb/1

SELECT T2.chef from(
SELECT DISTINCT c.chef from chefs c
WHERE c.dish IN (SELECT * FROM dishes)) T2
WHERE t2.chef NOT IN(
SELECT t3.chef from(
SELECT c.chef,count(*) as cout from chefs c 
CROSS JOIN dishes d
on c.dish=d.dish
group by c.chef
having cout <> (select count(*) from dishes))t3)

2) http://www.sqlfiddle.com/#!9/cdad2/2

SELECT result.chef as CHEFS from(
SELECT  c.chef ,c.dish, count(*) as cont  FROM chefs c 
 CROSS JOIN dishes d 
 ON c.dish=d.dish
GROUP BY c.chef
having cont IN (SELECT COUNT(*) FROM dishes)) result


3) http://www.sqlfiddle.com/#!9/157f6e/7

SELECT result.chef as CHEFS from( 
SELECT  c.chef ,c.dish, count(*) as cout  FROM chefs c 
 WHERE EXISTS(select * from dishes d where c.dish=d.dish)
GROUP BY c.chef
  HAVING cout=(SELECT COUNT(*) FROM dishes))result

4) could not check in sqlfiddle because of instability of sqlfiddle

select distinct chef from chefs where chef not in 
(
select distinct chef from 
(
select t2.chef, t3.dish from
(select * from (select  * from dishes) t1 join (select distinct chef from chefs)) t2 left outer join
chefs t3 on t2.chef = t3.chef and t3.dish = t2.dish
) where dish is null
)



